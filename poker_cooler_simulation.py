# -*- coding: utf-8 -*-
"""Poker Cooler Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XEoLJ3mmtGBmSHsNUQ2sHwihMGLMHd8T
"""

pip install treys

import random
from treys import Card, Deck, Evaluator
from itertools import combinations

# Function to convert card to treys format
def convert_to_treys(card):
    rank_char = card[0]
    suit_char = card[1]
    return Card.new(f"{rank_char}{suit_char}")

# Function to deal a hand of PLO
def deal_hand(deck, num_players, num_cards):
    random.shuffle(deck)
    hands = [deck[i*num_cards:(i+1)*num_cards] for i in range(num_players)]
    community_cards = deck[num_players*num_cards:num_players*num_cards+5]
    return hands, community_cards

# Function to evaluate hand strength in PLO
def plo_hand_strength(hand, community_cards, evaluator):
    treys_hand = [convert_to_treys(card) for card in hand]
    treys_community = [convert_to_treys(card) for card in community_cards]
    best_strength = float('inf')  # Lower is better in treys hand evaluation

    for hole_combo in combinations(treys_hand, 2):
        for comm_combo in combinations(treys_community, 3):
            strength = evaluator.evaluate(list(hole_combo), list(comm_combo))
            if strength < best_strength:
                best_strength = strength

    return best_strength

# Function to calculate equity using Monte Carlo simulation
def calculate_equity(hands, community_cards, evaluator, num_simulations=1000):
    win_count = [0] * len(hands)
    deck = Deck()

    for card in community_cards:
        deck.cards.remove(Card.new(card))
    for hand in hands:
        for card in hand:
            deck.cards.remove(Card.new(card))

    for _ in range(num_simulations):
        random.shuffle(deck.cards)
        remaining_community = deck.cards[:5-len(community_cards)]
        final_community = community_cards + [Card.int_to_str(card) for card in remaining_community]

        best_strengths = [plo_hand_strength(hand, final_community, evaluator) for hand in hands]
        best_strength = min(best_strengths)
        winners = [i for i, strength in enumerate(best_strengths) if strength == best_strength]

        for winner in winners:
            win_count[winner] += 1 / len(winners)

    return [win / num_simulations for win in win_count]

# Function to simulate hands and count coolers
def simulate_plo_hands(num_simulations, num_players, num_cards):
    evaluator = Evaluator()
    cooler_count = 0

    for _ in range(num_simulations):
        # Create a new deck and convert it to string format for easy handling
        deck = Deck()
        deck_cards = [Card.int_to_str(card) for card in deck.cards]

        # Deal the hands and community cards
        hands, community_cards = deal_hand(deck_cards, num_players, num_cards)

        # Evaluate hand strengths at different stages
        strengths_flop = [plo_hand_strength(hand, community_cards[:3], evaluator) for hand in hands]
        strengths_turn = [plo_hand_strength(hand, community_cards[:4], evaluator) for hand in hands]
        strengths_river = [plo_hand_strength(hand, community_cards[:5], evaluator) for hand in hands]

        # Calculate equity for each player at different stages
        equity_flop = calculate_equity(hands, community_cards[:3], evaluator)
        equity_turn = calculate_equity(hands, community_cards[:4], evaluator)
        equity_river = calculate_equity(hands, community_cards[:5], evaluator)


        # Check for coolers
        index_of_favorite_on_turn = [i for i, x in enumerate(equity_turn) if x >= .7]
        index_of_favorite_on_flop = [i for i, x in enumerate(equity_flop) if x >= .7]


        if index_of_favorite_on_turn != [] :
          if equity_river[index_of_favorite_on_turn[0]] != 1.0:
            cooler_count += 1

        if index_of_favorite_on_flop != []:
          if equity_river[index_of_favorite_on_flop[0]] != 1.0:
            cooler_count += 1


    return cooler_count

# Run the simulation for 10,000 hands of 4-card and 5-card PLO, 7-handed
num_simulations = 10000
num_players = 7
num_cards_4 = 4
num_cards_5 = 5

coolers_4_card = simulate_plo_hands(num_simulations, num_players, num_cards_4)
coolers_5_card = simulate_plo_hands(num_simulations, num_players, num_cards_5)

coolers_4_card, coolers_5_card